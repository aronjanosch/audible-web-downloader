{% extends "base.html" %}

{% block title %}Audible Book Downloader - Library{% endblock %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-4">
    <div>
        <h1 class="mb-2">
            <i class="fas fa-book-open"></i> Your Audible Library
        </h1>
        <p class="text-muted">Simple cross-platform Audible audiobook downloader and converter</p>
    </div>
    <div id="accountInfo" style="display: none;">
        <div class="text-end">
            <h5 id="currentAccountName"></h5>
            <small id="currentAccountRegion" class="text-muted"></small>
        </div>
    </div>
</div>

<!-- Welcome Message -->
<div id="welcomeMessage" class="text-center py-5">
    <i class="fas fa-book fa-3x text-muted mb-3"></i>
    <h3>Welcome to Audible Book Downloader</h3>
    <p class="text-muted">Please select or add an Audible account to get started.</p>
</div>

<!-- Library Content -->
<div id="libraryContent" style="display: none;">
    <!-- Search Bar -->
    <div class="row mb-4">
        <div class="col-md-6">
            <div class="input-group">
                <span class="input-group-text">
                    <i class="fas fa-search"></i>
                </span>
                <input type="text" class="form-control" id="searchInput" 
                       placeholder="Search books by title or author...">
            </div>
        </div>
        <div class="col-md-6 text-end">
            <button id="selectAllVisibleBtn" class="btn btn-sm btn-primary me-2">
                <i class="fas fa-check-double"></i> Select All Visible
            </button>
            <button id="clearSelectionBtn" class="btn btn-sm btn-secondary me-3">
                <i class="fas fa-times"></i> Clear Selection
            </button>
            <div class="btn-group view-switcher" role="group">
                <button type="button" class="btn btn-secondary active" id="cardViewBtn" title="Card View"><i class="fas fa-th-large"></i></button>
                <button type="button" class="btn btn-secondary" id="listViewBtn" title="List View"><i class="fas fa-list"></i></button>
            </div>
            <span id="bookCount" class="text-muted ms-3"></span>
        </div>
    </div>

    <!-- Filter Bar -->
    <div class="row mb-3">
        <div class="col-12">
            <div class="card">
                <div class="card-body py-2">
                    <div class="row g-2 align-items-center">
                        <div class="col-auto">
                            <label class="form-label mb-0 text-muted small">
                                <i class="fas fa-filter"></i> Filters:
                            </label>
                        </div>
                        <div class="col-md-2 col-sm-6">
                            <select class="form-select form-select-sm" id="languageFilter">
                                <option value="">All Languages</option>
                            </select>
                        </div>
                        <div class="col-md-2 col-sm-6">
                            <select class="form-select form-select-sm" id="narratorFilter">
                                <option value="">All Narrators</option>
                            </select>
                        </div>
                        <div class="col-md-2 col-sm-6">
                            <select class="form-select form-select-sm" id="seriesFilter">
                                <option value="">All Series</option>
                            </select>
                        </div>
                        <div class="col-md-2 col-sm-6">
                            <select class="form-select form-select-sm" id="publisherFilter">
                                <option value="">All Publishers</option>
                            </select>
                        </div>
                        <div class="col-md-2 col-sm-6">
                            <select class="form-select form-select-sm" id="releaseYearFilter">
                                <option value="">All Years</option>
                            </select>
                        </div>
                        <div class="col-auto">
                            <button class="btn btn-sm btn-outline-secondary" id="clearFiltersBtn" title="Clear all filters">
                                <i class="fas fa-times"></i> Clear
                            </button>
                        </div>
                    </div>
                    <div class="row mt-2" id="filterStatusRow" style="display: none;">
                        <div class="col-12">
                            <small class="text-muted" id="filterStatus"></small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Spinner -->
    <div id="loadingSpinner" class="text-center py-5" style="display: none;">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-3" id="loadingText">Loading your library...</p>
    </div>
    
    <!-- Library Grid -->
    <div id="libraryGrid" class="row g-4">
        <!-- Books will be dynamically loaded here -->
    </div>

    <!-- Library List -->
    <div id="libraryList" class="list-group" style="display: none;">
        <!-- Books will be dynamically loaded here -->
    </div>
    
    <!-- No Books Message -->
    <div id="noBooksMessage" class="text-center py-5" style="display: none;">
        <i class="fas fa-book fa-2x text-muted mb-3"></i>
        <h4>No books found</h4>
        <p class="text-muted">Click 'Refresh Library' to load your audiobooks.</p>
    </div>
</div>

<!-- Download Progress Modal -->
<div class="modal fade" id="downloadModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-download"></i> Downloading Books
                </h5>
            </div>
            <div class="modal-body">
                <div class="progress mb-3">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" 
                         role="progressbar" style="width: 0%"></div>
                </div>
                <p id="downloadStatus">Preparing download...</p>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    let currentView = 'card';
    let downloadStatusInterval = null;
    let progressEventSource = null;

    // Load accounts on page load
    async function loadAccounts() {
        try {
            const accounts = await apiCall('/api/accounts');
            updateAccountSelector(accounts);
        } catch (error) {
            showAlert('Failed to load accounts: ' + error.message, 'danger');
        }
    }
    
    function updateAccountSelector(accounts) {
        const select = document.getElementById('accountSelect');
        select.innerHTML = '<option value="">Select an account...</option>';
        
        Object.keys(accounts).forEach(accountName => {
            const option = document.createElement('option');
            option.value = accountName;
            option.textContent = accountName;
            option.dataset.region = accounts[accountName].region;
            select.appendChild(option);
        });
    }
    
    // Local library variables
    let localLibrary = [];
    let localLibraryId = null;
    let currentLibraryPath = '';
    let libraryComparison = null;
    let currentFilter = 'all';

    // Filter variables
    let currentlyDisplayedBooks = [];
    
    function setupEventListeners() {
        // Account selection
        document.getElementById('accountSelect').addEventListener('change', function() {
            const accountName = this.value;
            if (accountName) {
                selectAccount(accountName);
            } else {
                hideAccountInfo();
            }
        });

        // Add account form
        document.getElementById('addAccountForm').addEventListener('submit', function(e) {
            e.preventDefault();
            addAccount();
        });

        // Authentication
        document.getElementById('authenticateBtn').addEventListener('click', function() {
            authenticateAccount();
        });

        // Refresh library
        document.getElementById('refreshLibraryBtn').addEventListener('click', function() {
            fetchLibrary();
        });

        // Download
        document.getElementById('downloadBtn').addEventListener('click', function() {
            downloadSelectedBooks();
        });

        // Clear selection
        document.getElementById('clearSelectionBtn').addEventListener('click', function() {
            clearSelection();
        });

        // Select all visible books
        document.getElementById('selectAllVisibleBtn').addEventListener('click', function() {
            selectAllVisible();
        });

        // Search
        document.getElementById('searchInput').addEventListener('input', function() {
            searchBooks(this.value);
        });

        // View switcher
        document.getElementById('cardViewBtn').addEventListener('click', () => switchView('card'));
        document.getElementById('listViewBtn').addEventListener('click', () => switchView('list'));

        // Library management
        document.getElementById('addLibraryForm').addEventListener('submit', function(e) {
            e.preventDefault();
            addLibrary();
        });

        // Book filters
        document.getElementById('languageFilter').addEventListener('change', applyFilters);
        document.getElementById('narratorFilter').addEventListener('change', applyFilters);
        document.getElementById('seriesFilter').addEventListener('change', applyFilters);
        document.getElementById('publisherFilter').addEventListener('change', applyFilters);
        document.getElementById('releaseYearFilter').addEventListener('change', applyFilters);
        document.getElementById('clearFiltersBtn').addEventListener('click', clearAllFilters);

        // Load libraries on startup
        loadLibraries();
    }
    
    async function selectAccount(accountName) {
        try {
            await apiCall(`/api/accounts/${accountName}/select`, {
                method: 'POST'
            });
            
            currentAccount = accountName;
            showAccountInfo(accountName);
            checkAuthentication(accountName);
        } catch (error) {
            showAlert('Failed to select account: ' + error.message, 'danger');
        }
    }
    
    async function addAccount() {
        const accountName = document.getElementById('accountName').value;
        const region = document.getElementById('accountRegion').value;
        
        if (!accountName) {
            showAlert('Please enter an account name', 'warning');
            return;
        }
        
        try {
            const result = await apiCall('/api/accounts', {
                method: 'POST',
                body: JSON.stringify({
                    account_name: accountName,
                    region: region
                })
            });
            
            showAlert('Account added successfully!', 'success');
            document.getElementById('addAccountForm').reset();
            
            // Reload accounts and select the new one
            await loadAccounts();
            document.getElementById('accountSelect').value = accountName;
            selectAccount(accountName);
            
        } catch (error) {
            showAlert('Failed to add account: ' + error.message, 'danger');
        }
    }
    
    async function checkAuthentication(accountName) {
        try {
            const result = await apiCall('/api/auth/check', {
                method: 'POST',
                body: JSON.stringify({ account_name: accountName })
            });
            
            updateAuthStatus(result.authenticated);
        } catch (error) {
            showAlert('Failed to check authentication: ' + error.message, 'danger');
        }
    }
    
    async function authenticateAccount() {
        if (!currentAccount) return;
        
        // Redirect to web-based login flow
        window.location.href = `/auth/login/${currentAccount}`;
    }
    
    async function fetchLibrary() {
        if (!currentAccount) return;
        
        const btn = document.getElementById('refreshLibraryBtn');
        btn.setAttribute('data-original-text', btn.innerHTML);
        showLoading(btn, true);
        
        showLoadingSpinner('Loading your Audible library...');
        
        try {
            const result = await apiCall('/api/library/fetch', {
                method: 'POST',
                body: JSON.stringify({ account_name: currentAccount })
            });
            
            library = result.library;
            populateFilterDropdowns(library);
            displayLibrary(library);
            showAlert(`Loaded ${library.length} books!`, 'success');

            // Show compare button if we have local library data
            if (localLibraryId) {
                document.getElementById('compareLibrariesBtn').style.display = 'block';
            }
            
        } catch (error) {
            showAlert('Failed to load library: ' + error.message, 'danger');
        } finally {
            showLoading(btn, false);
            hideLoadingSpinner();
        }
    }
    
    function updateAuthStatus(isAuthenticated) {
        const statusDiv = document.getElementById('authStatus');
        const authBtn = document.getElementById('authenticateBtn');
        const refreshBtn = document.getElementById('refreshLibraryBtn');
        
        if (isAuthenticated) {
            statusDiv.className = 'alert alert-success';
            statusDiv.innerHTML = '<i class="fas fa-check-circle"></i> Authenticated';
            authBtn.style.display = 'none';
            refreshBtn.style.display = 'block';
            document.getElementById('downloadControls').style.display = 'block';
        } else {
            statusDiv.className = 'alert alert-warning';
            statusDiv.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Not authenticated';
            authBtn.style.display = 'block';
            refreshBtn.style.display = 'none';
            document.getElementById('downloadControls').style.display = 'none';
        }
    }
    
    function showAccountInfo(accountName) {
        document.getElementById('welcomeMessage').style.display = 'none';
        document.getElementById('libraryContent').style.display = 'block';
        document.getElementById('accountStatus').style.display = 'block';
        document.getElementById('accountInfo').style.display = 'block';
        document.getElementById('currentAccountName').textContent = accountName;
        
        // Get region from accounts
        const select = document.getElementById('accountSelect');
        const option = select.querySelector(`option[value="${accountName}"]`);
        if (option) {
            const region = option.getAttribute('data-region') || 'Unknown';
            document.getElementById('currentAccountRegion').textContent = `Region: ${region.toUpperCase()}`;
        }
    }
    
    function hideAccountInfo() {
        document.getElementById('welcomeMessage').style.display = 'block';
        document.getElementById('libraryContent').style.display = 'none';
        document.getElementById('accountStatus').style.display = 'none';
        document.getElementById('accountInfo').style.display = 'none';
        currentAccount = null;
        library = [];
        selectedBooks.clear();
        // Keep local library data as it's not account-specific
    }

    function switchView(view) {
        currentView = view;
        document.getElementById('cardViewBtn').classList.toggle('active', view === 'card');
        document.getElementById('listViewBtn').classList.toggle('active', view === 'list');
        displayLibrary(library);
    }
    
    function displayLibrary(books) {
        // Track currently displayed books for Select All functionality
        currentlyDisplayedBooks = books;

        const grid = document.getElementById('libraryGrid');
        const list = document.getElementById('libraryList');
        const countSpan = document.getElementById('bookCount');

        if (books.length === 0) {
            document.getElementById('noBooksMessage').style.display = 'block';
            grid.style.display = 'none';
            list.style.display = 'none';
        } else {
            document.getElementById('noBooksMessage').style.display = 'none';
            grid.innerHTML = '';
            list.innerHTML = '';

            if (currentView === 'card') {
                grid.style.display = 'flex';
                list.style.display = 'none';
                books.forEach(book => {
                    const bookCard = createBookCard(book);
                    grid.appendChild(bookCard);
                });
            } else {
                grid.style.display = 'none';
                list.style.display = 'block';
                books.forEach(book => {
                    const bookItem = createBookListItem(book);
                    list.appendChild(bookItem);
                });
            }
        }
        
        countSpan.textContent = `Showing ${books.length} books`;
    }
    
    function createBookCard(book) {
        const col = document.createElement('div');
        col.className = 'col-md-4 col-lg-3 col-xl-2';
        
        const hours = Math.floor(book.length_mins / 60);
        const minutes = book.length_mins % 60;
        const duration = book.length_mins ? `${hours}h ${minutes}m` : 'Unknown';
        
        col.innerHTML = `
            <div class="card book-card" data-asin="${book.asin}">
                <div class="status-overlay"></div>
                <input class="form-check-input book-checkbox position-absolute top-0 start-0 m-2" type="checkbox" id="book_${book.asin}" data-asin="${book.asin}">
                <img src="${book.cover_url || 'https://via.placeholder.com/150x200?text=No+Cover'}" 
                     class="card-img-top book-cover" alt="${book.title}">
                <div class="card-body">
                    <h6 class="card-title">${book.title}</h6>
                    <p class="card-text text-muted">${book.authors}</p>
                </div>
            </div>
        `;
        
        const card = col.querySelector('.book-card');
        card.addEventListener('click', () => {
            const checkbox = card.querySelector('.book-checkbox');
            checkbox.checked = !checkbox.checked;
            toggleBookSelection(book.asin, checkbox.checked);
        });
        
        return col;
    }

    function createBookListItem(book) {
        const item = document.createElement('div');
        item.className = 'list-group-item book-list-item';
        item.dataset.asin = book.asin;

        const hours = Math.floor(book.length_mins / 60);
        const minutes = book.length_mins % 60;
        const duration = book.length_mins ? `${hours}h ${minutes}m` : 'Unknown';

        item.innerHTML = `
            <input class="form-check-input book-checkbox me-3" type="checkbox" id="list_book_${book.asin}" data-asin="${book.asin}">
            <img src="${book.cover_url || 'https://via.placeholder.com/50x75?text=No+Cover'}" class="book-cover" alt="${book.title}">
            <div class="book-info">
                <h6 class="mb-1">${book.title}</h6>
                <p class="mb-1 text-muted">${book.authors}</p>
                <small class="text-muted">Length: ${duration}</small>
                <div class="progress-container mt-2" style="display: none;">
                    <div class="progress" style="height: 6px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated" 
                             role="progressbar" style="width: 0%"></div>
                    </div>
                    <small class="progress-text text-muted mt-1"></small>
                </div>
            </div>
            <div class="status-text"></div>
        `;

        item.addEventListener('click', (e) => {
            if (e.target.type !== 'checkbox') {
                const checkbox = item.querySelector('.book-checkbox');
                checkbox.checked = !checkbox.checked;
                toggleBookSelection(book.asin, checkbox.checked);
            }
        });

        const checkbox = item.querySelector('.book-checkbox');
        checkbox.addEventListener('change', function() {
            toggleBookSelection(book.asin, this.checked);
        });

        return item;
    }
    
    function toggleBookSelection(asin, selected) {
        const card = document.querySelector(`.book-card[data-asin="${asin}"]`);
        const listItem = document.querySelector(`.book-list-item[data-asin="${asin}"]`);

        if (selected) {
            selectedBooks.add(asin);
            if (card) {
                card.classList.add('book-selected');
                const checkbox = card.querySelector('.book-checkbox');
                if (checkbox) checkbox.checked = true;
            }
            if (listItem) {
                listItem.classList.add('book-selected');
                const checkbox = listItem.querySelector('.book-checkbox');
                if (checkbox) checkbox.checked = true;
            }
        } else {
            selectedBooks.delete(asin);
            if (card) {
                card.classList.remove('book-selected');
                const checkbox = card.querySelector('.book-checkbox');
                if (checkbox) checkbox.checked = false;
            }
            if (listItem) {
                listItem.classList.remove('book-selected');
                const checkbox = listItem.querySelector('.book-checkbox');
                if (checkbox) checkbox.checked = false;
            }
        }

        updateDownloadButton();
    }
    
    function updateDownloadButton() {
        const downloadBtn = document.getElementById('downloadBtn');
        const count = selectedBooks.size;
        
        if (count > 0) {
            downloadBtn.innerHTML = `<i class="fas fa-download"></i> Download Selected (${count})`;
            downloadBtn.disabled = false;
        } else {
            downloadBtn.innerHTML = `<i class="fas fa-download"></i> Download Selected`;
            downloadBtn.disabled = true;
        }
    }
    
    function clearSelection() {
        selectedBooks.clear();
        document.querySelectorAll('.book-checkbox').forEach(checkbox => {
            checkbox.checked = false;
        });
        document.querySelectorAll('.book-card, .book-list-item').forEach(item => {
            item.classList.remove('book-selected');
        });
        updateDownloadButton();
    }

    function selectAllVisible() {
        // Select all currently displayed books
        currentlyDisplayedBooks.forEach(book => {
            toggleBookSelection(book.asin, true);
        });
        updateDownloadButton();
        showAlert(`Selected ${currentlyDisplayedBooks.length} visible books`, 'info');
    }

    function searchBooks(query) {
        applyFilters(); // Use unified filter system
    }

    function populateFilterDropdowns(books) {
        // Get unique values for each filter, excluding empty values
        const languages = [...new Set(books.map(b => b.language).filter(v => v && v !== 'Unknown'))].sort();
        const narrators = [...new Set(books.map(b => b.narrator).filter(v => v))].sort();
        const series = [...new Set(books.map(b => b.series).filter(v => v))].sort();
        const publishers = [...new Set(books.map(b => b.publisher).filter(v => v))].sort();
        const years = [...new Set(books.map(b => b.release_year).filter(v => v))].sort().reverse(); // Most recent first

        // Populate language filter
        const languageSelect = document.getElementById('languageFilter');
        const currentLanguage = languageSelect.value;
        languageSelect.innerHTML = '<option value="">All Languages</option>';
        languages.forEach(lang => {
            const option = document.createElement('option');
            option.value = lang;
            option.textContent = lang;
            languageSelect.appendChild(option);
        });
        if (currentLanguage) languageSelect.value = currentLanguage;

        // Populate narrator filter
        const narratorSelect = document.getElementById('narratorFilter');
        const currentNarrator = narratorSelect.value;
        narratorSelect.innerHTML = '<option value="">All Narrators</option>';
        narrators.forEach(narrator => {
            const option = document.createElement('option');
            option.value = narrator;
            option.textContent = narrator;
            narratorSelect.appendChild(option);
        });
        if (currentNarrator) narratorSelect.value = currentNarrator;

        // Populate series filter
        const seriesSelect = document.getElementById('seriesFilter');
        const currentSeries = seriesSelect.value;
        seriesSelect.innerHTML = '<option value="">All Series</option>';
        series.forEach(s => {
            const option = document.createElement('option');
            option.value = s;
            option.textContent = s;
            seriesSelect.appendChild(option);
        });
        if (currentSeries) seriesSelect.value = currentSeries;

        // Populate publisher filter
        const publisherSelect = document.getElementById('publisherFilter');
        const currentPublisher = publisherSelect.value;
        publisherSelect.innerHTML = '<option value="">All Publishers</option>';
        publishers.forEach(pub => {
            const option = document.createElement('option');
            option.value = pub;
            option.textContent = pub;
            publisherSelect.appendChild(option);
        });
        if (currentPublisher) publisherSelect.value = currentPublisher;

        // Populate year filter
        const yearSelect = document.getElementById('releaseYearFilter');
        const currentYear = yearSelect.value;
        yearSelect.innerHTML = '<option value="">All Years</option>';
        years.forEach(year => {
            const option = document.createElement('option');
            option.value = year;
            option.textContent = year;
            yearSelect.appendChild(option);
        });
        if (currentYear) yearSelect.value = currentYear;
    }

    function applyFilters() {
        let filtered = library;

        // Apply search filter
        const searchQuery = document.getElementById('searchInput').value;
        if (searchQuery.trim()) {
            filtered = filtered.filter(book =>
                book.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                book.authors.toLowerCase().includes(searchQuery.toLowerCase())
            );
        }

        // Apply language filter
        const language = document.getElementById('languageFilter').value;
        if (language) {
            filtered = filtered.filter(book => book.language === language);
        }

        // Apply narrator filter
        const narrator = document.getElementById('narratorFilter').value;
        if (narrator) {
            filtered = filtered.filter(book => book.narrator === narrator);
        }

        // Apply series filter
        const series = document.getElementById('seriesFilter').value;
        if (series) {
            filtered = filtered.filter(book => book.series === series);
        }

        // Apply publisher filter
        const publisher = document.getElementById('publisherFilter').value;
        if (publisher) {
            filtered = filtered.filter(book => book.publisher === publisher);
        }

        // Apply release year filter
        const releaseYear = document.getElementById('releaseYearFilter').value;
        if (releaseYear) {
            filtered = filtered.filter(book => book.release_year === releaseYear);
        }

        // Apply library comparison filter if active
        if (currentFilter !== 'all' && libraryComparison) {
            if (currentFilter === 'missing') {
                const localAsins = new Set(libraryComparison.local_books.map(b => b.asin));
                filtered = filtered.filter(book => !localAsins.has(book.asin));
            } else if (currentFilter === 'available') {
                const localAsins = new Set(libraryComparison.local_books.map(b => b.asin));
                filtered = filtered.filter(book => localAsins.has(book.asin));
            }
        }

        // Update filter status display
        updateFilterStatus(filtered.length);

        // Display filtered results
        displayLibrary(filtered);
    }

    function updateFilterStatus(filteredCount) {
        const activeFilters = [];

        if (document.getElementById('languageFilter').value) activeFilters.push('Language');
        if (document.getElementById('narratorFilter').value) activeFilters.push('Narrator');
        if (document.getElementById('seriesFilter').value) activeFilters.push('Series');
        if (document.getElementById('publisherFilter').value) activeFilters.push('Publisher');
        if (document.getElementById('releaseYearFilter').value) activeFilters.push('Year');
        if (document.getElementById('searchInput').value.trim()) activeFilters.push('Search');

        const statusRow = document.getElementById('filterStatusRow');
        const statusText = document.getElementById('filterStatus');

        if (activeFilters.length > 0) {
            statusRow.style.display = 'block';
            const totalBooks = library.length;
            statusText.innerHTML = `<i class="fas fa-info-circle"></i> Showing <strong>${filteredCount}</strong> of <strong>${totalBooks}</strong> books | Active filters: <strong>${activeFilters.join(', ')}</strong>`;
        } else {
            statusRow.style.display = 'none';
        }
    }

    function clearAllFilters() {
        document.getElementById('languageFilter').value = '';
        document.getElementById('narratorFilter').value = '';
        document.getElementById('seriesFilter').value = '';
        document.getElementById('publisherFilter').value = '';
        document.getElementById('releaseYearFilter').value = '';
        document.getElementById('searchInput').value = '';
        applyFilters();
    }

    async function downloadSelectedBooks() {
        if (selectedBooks.size === 0) {
            showAlert('Please select books to download', 'warning');
            return;
        }

        const cleanupAax = document.getElementById('cleanupAax').checked;
        const libraryName = document.getElementById('downloadLibrarySelect').value;

        if (!libraryName) {
            showAlert('Please select a library to download to', 'warning');
            return;
        }

        // Start SSE-based progress tracking immediately before making the download request
        startProgressTracking();

        try {
            const result = await apiCall('/api/download/books', {
                method: 'POST',
                body: JSON.stringify({
                    selected_asins: Array.from(selectedBooks),
                    cleanup_aax: cleanupAax,
                    library_name: libraryName
                })
            });

            showAlert(result.message, 'success');

        } catch (error) {
            showAlert('Download failed: ' + error.message, 'danger');
            // Stop progress tracking if download failed to start
            stopProgressTracking();
        }
    }

    function startProgressTracking() {
        // Stop any existing progress tracking
        stopProgressTracking();
        
        // Create Server-Sent Events connection
        progressEventSource = new EventSource('/api/download/progress-stream');
        
        progressEventSource.onmessage = function(event) {
            try {
                const progressData = JSON.parse(event.data);
                
                // Check for errors
                if (progressData.error) {
                    console.error('Progress tracking error:', progressData.error);
                    showAlert('Progress tracking error: ' + progressData.error, 'warning');
                    return;
                }
                
                // Update progress for all books
                if (progressData && typeof progressData === 'object') {
                    for (const [asin, progress] of Object.entries(progressData)) {
                        updateBookProgress(asin, progress);
                    }
                }
                
            } catch (error) {
                console.error('Failed to parse progress data:', error);
            }
        };
        
        progressEventSource.onerror = function(event) {
            console.error('EventSource failed:', event);
            // EventSource will automatically try to reconnect
        };
        
        progressEventSource.onopen = function(event) {
            console.log('Progress tracking connected');
        };
    }
    
    function stopProgressTracking() {
        if (progressEventSource) {
            progressEventSource.close();
            progressEventSource = null;
            console.log('Progress tracking stopped');
        }
    }

    function updateBookProgress(asin, progressInfo) {
        const card = document.querySelector(`.book-card[data-asin="${asin}"]`);
        const listItem = document.querySelector(`.book-list-item[data-asin="${asin}"]`);

        if (!card && !listItem) return;
        
        console.log(`Updating ${asin}: ${progressInfo.state} - ${progressInfo.progress_percent}%`);

        let statusText = '';
        let progressPercent = progressInfo.progress_percent || 0;
        
        switch (progressInfo.state) {
            case 'pending':
                statusText = 'Pending...';
                break;
            case 'license_requested':
                statusText = 'Requesting license...';
                break;
            case 'license_granted':
                statusText = 'License granted';
                break;
            case 'downloading':
                if (progressInfo.total_bytes && progressInfo.downloaded_bytes) {
                    const mbDownloaded = (progressInfo.downloaded_bytes / 1024 / 1024).toFixed(1);
                    const mbTotal = (progressInfo.total_bytes / 1024 / 1024).toFixed(1);
                    statusText = `${Math.round(progressPercent)}% (${mbDownloaded}/${mbTotal} MB)`;
                } else {
                    statusText = 'Downloading...';
                }
                break;
            case 'download_complete':
                statusText = 'Download complete';
                break;
            case 'decrypting':
                statusText = 'Converting...';
                break;
            case 'converted':
                statusText = '✅ Complete';
                break;
            case 'error':
                statusText = `❌ Error`;
                break;
            default:
                statusText = progressInfo.state;
        }

        // Update card view - simple status overlay
        if (card) {
            const overlay = card.querySelector('.status-overlay');
            if (progressInfo.state === 'converted') {
                overlay.style.display = 'none';
            } else {
                overlay.textContent = statusText;
                overlay.style.display = 'flex';
            }
        }

        // Update list view
        if (listItem) {
            const statusEl = listItem.querySelector('.status-text');
            statusEl.textContent = statusText;
        }
    }
    
    function showLoadingSpinner(text) {
        document.getElementById('loadingSpinner').style.display = 'block';
        document.getElementById('loadingText').textContent = text;
        document.getElementById('libraryGrid').style.display = 'none';
        document.getElementById('libraryList').style.display = 'none';
    }
    
    function hideLoadingSpinner() {
        document.getElementById('loadingSpinner').style.display = 'none';
        if (currentView === 'card') {
            document.getElementById('libraryGrid').style.display = 'flex';
        } else {
            document.getElementById('libraryList').style.display = 'block';
        }
    }
    
    // Local library functions
    async function setLibraryPath() {
        const path = document.getElementById('libraryPath').value.trim();
        if (!path) {
            showAlert('Please enter a library path', 'warning');
            return;
        }
        
        try {
            const result = await apiCall('/api/library/set-path', {
                method: 'POST',
                body: JSON.stringify({ library_path: path })
            });
            
            showAlert(result.message, 'success');
        } catch (error) {
            showAlert('Failed to set library path: ' + error.message, 'danger');
        }
    }
    
    async function scanLocalLibrary() {
        const path = document.getElementById('libraryPath').value.trim();
        if (!path) {
            showAlert('Please set a library path first', 'warning');
            return;
        }
        
        const btn = document.getElementById('scanLocalBtn');
        btn.setAttribute('data-original-text', btn.innerHTML);
        showLoading(btn, true);
        
        try {
            const result = await apiCall('/api/library/scan-local', {
                method: 'POST',
                body: JSON.stringify({ library_path: path })
            });
            
            // Store library information
            localLibrary = result.books || [];
            localLibraryId = result.library_id;
            currentLibraryPath = result.library_path;
            
            const message = result.cached ? 
                `Loaded ${result.book_count} books from cached library (last scanned: ${new Date(result.last_scanned).toLocaleDateString()})` :
                `Scanned ${result.book_count} books from local library`;
            
            showAlert(message, 'success');
            
            // Update stats if available
            if (result.stats) {
                updateLibraryStats(result.stats);
            }
            
            // Show compare button if we have both libraries
            if (library.length > 0) {
                document.getElementById('compareLibrariesBtn').style.display = 'block';
            }
            
        } catch (error) {
            showAlert('Failed to scan library: ' + error.message, 'danger');
        } finally {
            showLoading(btn, false);
        }
    }
    
    async function compareLibraries() {
        if (library.length === 0) {
            showAlert('Please fetch your Audible library first', 'warning');
            return;
        }
        
        if (!localLibraryId) {
            showAlert('Please scan your local library first', 'warning');
            return;
        }
        
        const btn = document.getElementById('compareLibrariesBtn');
        btn.setAttribute('data-original-text', btn.innerHTML);
        showLoading(btn, true);
        
        try {
            const result = await apiCall('/api/library/compare', {
                method: 'POST',
                body: JSON.stringify({ 
                    audible_library: library,
                    library_id: localLibraryId,
                    audible_account: currentAccount || 'unknown'
                })
            });
            libraryComparison = result.comparison;
            
            // Show filter buttons
            document.getElementById('missingBooksFilter').style.display = 'inline-block';
            document.getElementById('availableBooksFilter').style.display = 'inline-block';
            document.getElementById('showMissingBtn').style.display = 'block';
            
            // Update stats
            updateLibraryStats(libraryComparison);
            
            // Re-display library with availability indicators
            displayLibraryWithAvailability();
            
            showAlert(`Found ${libraryComparison.missing_count} missing books and ${libraryComparison.available_count} available locally`, 'info');
            
        } catch (error) {
            showAlert('Failed to compare libraries: ' + error.message, 'danger');
        } finally {
            showLoading(btn, false);
        }
    }
    
    function toggleFilter(filter) {
        currentFilter = filter;
        
        // Update active filter button
        document.querySelectorAll('.library-filter').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[data-filter="${filter}"]`).classList.add('active');
        
        // Filter and display books
        let booksToShow = library;
        
        if (libraryComparison) {
            switch (filter) {
                case 'missing':
                    booksToShow = libraryComparison.missing_from_local;
                    break;
                case 'available':
                    booksToShow = libraryComparison.available_locally;
                    break;
                case 'all':
                default:
                    booksToShow = library;
                    break;
            }
        }
        
        displayLibrary(booksToShow);
    }
    
    function displayLibraryWithAvailability() {
        if (!libraryComparison) {
            displayLibrary(library);
            return;
        }
        
        // Add availability info to books
        const missingAsins = new Set(libraryComparison.missing_from_local.map(book => book.asin));
        const availableAsins = new Set(libraryComparison.available_locally.map(book => book.asin));
        
        const booksWithAvailability = library.map(book => ({
            ...book,
            availability: missingAsins.has(book.asin) ? 'missing' : (availableAsins.has(book.asin) ? 'available' : 'unknown')
        }));
        
        displayLibrary(booksWithAvailability);
    }
    
    function updateLibraryStats(stats) {
        const statsEl = document.getElementById('libraryStats');
        const statsTextEl = document.getElementById('statsText');
        
        if (stats) {
            // Handle both comparison stats and library scan stats
            if (stats.total_audible !== undefined) {
                // This is comparison stats
                const coverage = ((stats.available_count / stats.total_audible) * 100).toFixed(1);
                statsTextEl.innerHTML = `
                    <div>Audible: ${stats.total_audible} books</div>
                    <div>Local: ${stats.total_local} books</div>
                    <div>Missing: ${stats.missing_count} books</div>
                    <div>Coverage: ${coverage}%</div>
                `;
            } else {
                // This is library scan stats
                const sizeGB = stats.total_size_gb ? stats.total_size_gb.toFixed(2) : '0';
                const avgHours = stats.avg_duration_hours ? stats.avg_duration_hours.toFixed(1) : '0';
                const languageList = Object.entries(stats.languages || {})
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(([lang, count]) => `${lang}: ${count}`)
                    .join(', ');
                
                statsTextEl.innerHTML = `
                    <div>Books: ${stats.total_books}</div>
                    <div>Size: ${sizeGB} GB</div>
                    <div>Avg Length: ${avgHours}h</div>
                    ${languageList ? `<div>Languages: ${languageList}</div>` : ''}
                `;
            }
            statsEl.style.display = 'block';
        } else {
            statsEl.style.display = 'none';
        }
    }
    
    // Override the original createBookCard to add availability indicators
    function createBookCard(book) {
        const col = document.createElement('div');
        col.className = 'col-md-4 col-lg-3 col-xl-2';
        
        const hours = Math.floor(book.length_mins / 60);
        const minutes = book.length_mins % 60;
        const duration = book.length_mins ? `${hours}h ${minutes}m` : 'Unknown';
        
        // Add availability class
        let availabilityClass = '';
        let availabilityIcon = '';
        
        if (book.availability === 'missing') {
            availabilityClass = 'book-missing';
            availabilityIcon = '<i class="fas fa-exclamation-circle text-danger position-absolute top-0 end-0 m-2"></i>';
        } else if (book.availability === 'available') {
            availabilityClass = 'book-available';
            availabilityIcon = '<i class="fas fa-check-circle text-success position-absolute top-0 end-0 m-2"></i>';
        }
        
        col.innerHTML = `
            <div class="card book-card ${availabilityClass}" data-asin="${book.asin}">
                <div class="status-overlay"></div>
                ${availabilityIcon}
                <input class="form-check-input book-checkbox position-absolute top-0 start-0 m-2" type="checkbox" id="book_${book.asin}" data-asin="${book.asin}">
                <img src="${book.cover_url || 'https://via.placeholder.com/150x200?text=No+Cover'}" 
                     class="card-img-top book-cover" alt="${book.title}">
                <div class="card-body">
                    <h6 class="card-title">${book.title}</h6>
                    <p class="card-text text-muted">${book.authors}</p>
                </div>
            </div>
        `;
        
        const card = col.querySelector('.book-card');
        card.addEventListener('click', (e) => {
            if (e.target.classList.contains('fas')) return; // Don't select when clicking icons
            const checkbox = card.querySelector('.book-checkbox');
            checkbox.checked = !checkbox.checked;
            toggleBookSelection(book.asin, checkbox.checked);
        });
        
        return col;
    }
    
    async function viewDebugLog(filename) {
        if (!filename) {
            showAlert('No debug file available', 'warning');
            return;
        }
        
        try {
            const result = await apiCall(`/api/library/debug-log/${filename}`);
            
            if (result.success) {
                showDebugModal(result.debug_data, filename);
            } else {
                showAlert('Failed to load debug file', 'danger');
            }
        } catch (error) {
            showAlert('Error loading debug file: ' + error.message, 'danger');
        }
    }
    
    function showDebugModal(debugData, filename) {
        // Create debug modal content
        const logEntries = debugData.log_entries || [];
        
        // Find matching attempts for better overview
        const matchingAttempts = logEntries.filter(entry => 
            entry.message.includes('Processing Audible Book') || 
            entry.message.includes('RESULT:')
        );
        
        let debugHtml = `
            <div class="debug-info">
                <h5>Debug Log: ${filename}</h5>
                <div class="mb-3">
                    <strong>Comparison Settings:</strong><br>
                    Match Threshold: ${debugData.match_threshold}<br>
                    Author Threshold: ${debugData.author_threshold}<br>
                    Total Log Entries: ${debugData.total_log_entries}
                </div>
                
                <div class="debug-summary mb-3">
                    <strong>Summary:</strong><br>
        `;
        
        // Count results
        const matchedCount = logEntries.filter(e => e.message === 'RESULT: MATCHED').length;
        const notMatchedCount = logEntries.filter(e => e.message === 'RESULT: NOT MATCHED').length;
        
        debugHtml += `
                    Matched: ${matchedCount}<br>
                    Not Matched: ${notMatchedCount}<br>
                    Total Processed: ${matchedCount + notMatchedCount}
                </div>
                
                <div class="accordion" id="debugAccordion">
        `;
        
        // Group entries by book processing
        let currentBook = null;
        let bookEntries = [];
        let bookIndex = 0;
        
        for (const entry of logEntries) {
            if (entry.message.includes('Processing Audible Book')) {
                // Save previous book if exists
                if (currentBook && bookEntries.length > 0) {
                    debugHtml += createBookDebugSection(currentBook, bookEntries, bookIndex++);
                }
                
                // Start new book
                currentBook = entry;
                bookEntries = [entry];
            } else if (currentBook && (entry.message.includes('RESULT:') || entry.message.includes('Audible Book Details'))) {
                bookEntries.push(entry);
            }
        }
        
        // Add last book
        if (currentBook && bookEntries.length > 0) {
            debugHtml += createBookDebugSection(currentBook, bookEntries, bookIndex);
        }
        
        debugHtml += `
                </div>
                
                <div class="mt-3">
                    <button class="btn btn-secondary" onclick="downloadDebugFile('${filename}')">Download Full Log</button>
                </div>
            </div>
        `;
        
        // Show in modal
        const existingModal = document.getElementById('debugModal');
        if (existingModal) {
            existingModal.remove();
        }
        
        const modalHtml = `
            <div class="modal fade" id="debugModal" tabindex="-1">
                <div class="modal-dialog modal-xl">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">Matching Debug Information</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                            ${debugHtml}
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
        // Show modal
        const modal = new bootstrap.Modal(document.getElementById('debugModal'));
        modal.show();
    }
    
    function createBookDebugSection(bookEntry, entries, index) {
        const bookData = bookEntry.data || {};
        const resultEntry = entries.find(e => e.message.includes('RESULT:'));
        const isMatched = resultEntry && resultEntry.message.includes('MATCHED');
        
        const panelClass = isMatched ? 'bg-success-subtle' : 'bg-danger-subtle';
        const headerClass = isMatched ? 'text-success' : 'text-danger';
        const resultText = isMatched ? '✅ MATCHED' : '❌ NOT MATCHED';
        
        let html = `
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading${index}">
                    <button class="accordion-button collapsed ${panelClass}" type="button" 
                            data-bs-toggle="collapse" data-bs-target="#collapse${index}">
                        <span class="${headerClass} fw-bold me-2">${resultText}</span>
                        <span>${bookData.title || 'Unknown Title'} by ${bookData.authors || 'Unknown Author'}</span>
                    </button>
                </h2>
                <div id="collapse${index}" class="accordion-collapse collapse" 
                     data-bs-parent="#debugAccordion">
                    <div class="accordion-body">
        `;
        
        // Show book details and matching attempts
        for (const entry of entries) {
            if (entry.data) {
                html += `<div class="mb-2"><strong>${entry.message}:</strong><br>`;
                html += `<pre class="bg-light p-2 small">${JSON.stringify(entry.data, null, 2)}</pre></div>`;
            }
        }
        
        html += `
                    </div>
                </div>
            </div>
        `;
        
        return html;
    }
    
    async function downloadDebugFile(filename) {
        window.open(`/api/library/debug-log/${filename}`, '_blank');
    }
    
    // Add global function for modal cleanup
    window.addEventListener('hidden.bs.modal', function(event) {
        if (event.target.id === 'debugModal') {
            event.target.remove();
        }
    });

    // Library management functions
    async function loadLibraries() {
        try {
            const libraries = await apiCall('/api/libraries');
            updateLibraryList(libraries);
            updateLibrarySelector(libraries);
        } catch (error) {
            console.error('Failed to load libraries:', error);
        }
    }

    function updateLibraryList(libraries) {
        const listContainer = document.getElementById('configuredLibraryList');

        if (Object.keys(libraries).length === 0) {
            listContainer.innerHTML = '<small class="text-light">No libraries configured</small>';
            return;
        }

        listContainer.innerHTML = '';

        for (const [name, library] of Object.entries(libraries)) {
            const libraryItem = document.createElement('div');
            libraryItem.className = 'card bg-light text-dark mb-2';
            libraryItem.innerHTML = `
                <div class="card-body p-2">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <strong>${name}</strong><br>
                            <small class="text-muted">${library.path}</small>
                        </div>
                        <button class="btn btn-sm btn-danger" onclick="deleteLibrary('${name}')">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
            listContainer.appendChild(libraryItem);
        }
    }

    function updateLibrarySelector(libraries) {
        const select = document.getElementById('downloadLibrarySelect');
        const libraryKeys = Object.keys(libraries);

        if (libraryKeys.length === 0) {
            select.innerHTML = '<option value="">No libraries configured</option>';
            select.disabled = true;
        } else {
            select.innerHTML = '<option value="">Select a library...</option>';
            select.disabled = false;

            for (const name of libraryKeys) {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            }

            // Auto-select if only one library exists
            if (libraryKeys.length === 1) {
                select.value = libraryKeys[0];
            }
        }
    }

    async function addLibrary() {
        const libraryName = document.getElementById('libraryName').value.trim();
        const libraryPath = document.getElementById('libraryPath').value.trim();

        if (!libraryName || !libraryPath) {
            showAlert('Please enter both library name and path', 'warning');
            return;
        }

        try {
            await apiCall('/api/libraries', {
                method: 'POST',
                body: JSON.stringify({
                    library_name: libraryName,
                    library_path: libraryPath
                })
            });

            showAlert('Library added successfully!', 'success');
            document.getElementById('addLibraryForm').reset();
            loadLibraries();

        } catch (error) {
            showAlert('Failed to add library: ' + error.message, 'danger');
        }
    }

    async function deleteLibrary(libraryName) {
        if (!confirm(`Are you sure you want to remove the library "${libraryName}"?\n\nNote: This only removes it from the app, your files will not be deleted.`)) {
            return;
        }

        try {
            await apiCall(`/api/libraries/${libraryName}`, {
                method: 'DELETE'
            });

            showAlert('Library removed successfully', 'success');
            loadLibraries();

        } catch (error) {
            showAlert('Failed to remove library: ' + error.message, 'danger');
        }
    }
</script>
{% endblock %}